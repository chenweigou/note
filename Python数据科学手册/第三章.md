# Python 数据科学手册

[返回](./index.md)

[toc]

## 第三章 Pandas数据处理

### 3.1 安装并使用Pandas

我们将导入 Pandas 并使用别名 pd：

```python
In[2]: import pandas as pd
```

### 3.2 Pandas对象简介

Pandas 的三个基本数据结构： Series、 DataFrame 和 Index。

#### 3.2.1 Pandas的Series对象

Pandas 的 Series 对象是一个带索引数据构成的一维数组。 

```python
In[2]:  data = pd.Series([0.25, 0.5, 0.75, 1.0])
        data
Out[2]: 0 0.25
        1 0.50
        2 0.75
        3 1.00
dtype: float64
```

我们可以通过 values 属性和 index 属性获取数据， 也可以通过 Python 的中括号索引标签获取。

```python
In[3]: data.values
Out[3]: array([ 0.25, 0.5 , 0.75, 1. ])

In[4]: data.index
Out[4]: RangeIndex(start=0, stop=4, step=1)

In[5]: data[1]
Out[5]: 0.5
In[6]: data[1:3]
Out[6]: 1 0.50
        2 0.75
dtype: float64
```

01. Serise是通用的NumPy数组
    Series 对象和一维 NumPy 数组两者间的本质差异其实是索引： NumPy 数组通过隐式定义的整数索引获取数值， 而 Pandas 的 Series 对象用一种显式定义的索引与数值关联。

    ```python
    In[7]:  data = pd.Series([0.25, 0.5, 0.75, 1.0],
            index=['a', 'b', 'c', 'd'])data
    Out[7]: a 0.25
            b 0.50
            c 0.75
            d 1.00
            dtype: float64
    ```

02. Series是特殊的字典
    可以把 Pandas 的 Series 对象看成一种特殊的 Python 字典，可以直接用 Python 的字典创建一个 Series 对象。

    ```python
    In[11]:  population_dict = {'California': 38332521,
                                'Texas': 26448193,
                                'New York': 19651127,
                                'Florida': 19552860,
                                'Illinois': 12882135}
            population = pd.Series(population_dict)
            population
    Out[11]: California 38332521
             Florida 19552860
             Illinois 12882135
             New York 19651127
             Texas 26448193
             dtype: int64
    ```

03. 创建Series对象

    ```python
        pd.Series(data, index=index)
    ```

    其中， index 是一个可选参数， data 参数支持多种数据类型。

    * data 可以是列表或 NumPy 数组， 这时 index 默认值为整数序列
    * data 也可以是一个标量， 创建 Series 对象时会重复填充到每个索引上
    * data 还可以是一个字典， index 默认是排序的字典键

    每一种形式都可以通过显式指定索引筛选需要的结果：

    ```python
    In[17]: pd.Series({2:'a', 1:'b', 3:'c'}, index=[3, 2])
    Out[17]: 3 c
             2 a
             dtype: object
    ```

#### 3.2.2 Pandas的DataFrame对象

01. DataFrame是通用的NumPy数组
    如果将 Series 类比为带灵活索引的一维数组， 那么 DataFrame就可以看作是一种既有灵活的行索引， 又有灵活列名的二维数组。也可以把 DataFrame 看成是有序排列的若干 Series 对象。

    ```python
    In[19]: states = pd.DataFrame({'population': population,'area': area})
            states
    Out[19]:            area        population
             California 423967      38332521
             Florida    170312      19552860
             Illinois   149995      12882135
             New York   141297      19651127
             Texas      695662      26448193
    ```

02. DataFrame是特殊的字典
    也可以把 DataFrame 看成一种特殊的字典。 字典是一个键映射一个值， 而 DataFrame 是一列映射一个Series 的数据。

    ```python
    In[22]: states['area']
    Out[22]: California 423967
             Florida 170312
             Illinois 149995
             New York 141297
             Texas 695662
             Name: area, dtyp
    ```

03. 创建DataFrame对象：

    (1). 通过单个 Series 对象创建。

    ```python
    In[23]: pd.DataFrame(population, columns=['population'])
    Out[23]: population
             California 38332521
             Florida 19552860
             Illinois 12882135
             New York 19651127
             Texas 26448193
    ```

    (2). 通过字典列表创建。

    ```python
    In[24]: data = [{'a': i, 'b': 2 * i}
                    for i in range(3)]
            pd.DataFrame(data)
    Out[24]:  a b
            0 0 0
            1 1 2
            2 2 4
    ```

    如果字典中有些键不存在， Pandas 会用缺失值 NaN（不是数字，not a number） 来表示

    (3). 通过 Series 对象字典创建。

    ```python
    In[26]: pd.DataFrame({'population': population,'area': area})
    Out[26]: area population
             California 423967 38332521
             Florida 170312 19552860
             Illinois 149995 12882135
             New York 141297 19651127
             Texas 695662 26448193
    ```

    (4). 通过 NumPy 二维数组创建。

    ```python
    In[27]: pd.DataFrame(np.random.rand(3, 2),
            columns=['foo', 'bar'],
            index=['a', 'b', 'c'])
    Out[27]: foo bar
             a 0.865257 0.213169
             b 0.442759 0.108267
             c 0.047110 0.905718
    ```

    (5). 通过 NumPy 结构化数组创建。

    ```python
    In[28]: A = np.zeros(3, dtype=[('A', 'i8'), ('B', 'f8')])
            A
    Out[28]: array([(0, 0.0), (0, 0.0), (0, 0.0)],
                    dtype=[('A', '<i8'), ('B', '<f8')])

    In[29]: pd.DataFrame(A)
    Out[29]:  A B
            0 0 0.0
            1 0 0.0
            2 0 0.0
    ```

#### 3.2.3 Pandas的Index对象

01. 将Index看作不可变数组
    Index 对象的许多操作都像数组。 

    ```python
    In[31]: ind[1]
    Out[31]: 3

    In[32]: ind[::2]
    Out[32]: Int64Index([2, 5, 11], dtype='int64')
    ```

    Index 对象还有许多与 NumPy 数组相似的属性：`ind.size, ind.shape, ind.ndim, ind.dtype`， 不同在于， Index 对象的索引是不可变的，`ind[1] = 0` 这样的操作是不可行的。

02. 将Index看作有序集合

    Pandas 对象被设计用于实现许多操作， 如连接（join） 数据集， 其中会涉及许多集合操作。 Index 对象遵循 Python 标准库的集合（set） 数据结构的许多习惯用法， 包括并集、 交集、 差集等：

    ```python
    In[35]: indA = pd.Index([1, 3, 5, 7, 9])
            indB = pd.Index([2, 3, 5, 7, 11])

    In[36]: indA & indB # 交集
    Out[36]: Int64Index([3, 5, 7], dtype='int64')

    In[37]: indA | indB # 并集
    Out[37]: Int64Index([1, 2, 3, 5, 7, 9, 11], dtype='int64')

    In[38]: indA ^ indB # 异或
    Out[38]: Int64Index([1, 2, 9, 11], dtype='int64')
    ```

这些操作还可以通过调用对象方法来实现， 例如indA.intersection(indB)。

### 3.3 数据取值与选择

#### 3.3.1 Series数据选择方法

01. 将Series看作字典
02. 将Series看作一维数组
03. 索引器： loc、 iloc和i
    如果你的Series 是显式整数索引， 那么 data[1] 这样的取值操作会使用显式索引， 而 data[1:3] 这样的切片操作却会使用隐式索引。

    ```python
    In[11]: data = pd.Series(['a', 'b', 'c'], index=[1, 3, 5])
            data
    Out[11]: 1 a
             3 b
             5 c
             dtype: object
    In[12]: # 取值操作是显式索引
            data[1]
    Out[12]: 'a'
    In[13]: # 切片操作是隐式索引
            data[1:3]
    Out[13]: 3 b
             5 c
             dtype: object
    ```

    由于整数索引很容易造成混淆， 所以 Pandas 提供了一些索引器（indexer） 属性来作为取值的方法。

    第一种索引器是 loc 属性， 表示取值和切片都是显式的：

    ```python
    In[14]: data.loc[1]
    Out[14]: 'a'
    In[15]: data.loc[1:3]
    Out[15]: 1 a
             3 b
             dtype: object
    ```

    第二种是 iloc 属性， 表示取值和切片都是 Python 形式的 隐式索引：

    ```python
    In[16]: data.iloc[1]
    Out[16]: 'b'
    In[17]: data.iloc[1:3]
    Out[17]: 3 b
             5 c
             dtype: object
    ```

    第三种取值属性是 ix， 它是前两种索引器的混合形式， 在 Series对象中 ix 等价于标准的 []（Python 列表） 取值方式。

#### 3.3.2 DataFrame数据选择方法

01. 将DataFrame看作字典
    可以通过对列名进行字典形式（dictionary-style） 的取值获取数据， 也可以用属性形式（attribute-style） 选择纯字符串列名的数据、
    应该避免对用属性形式选择的列直接赋值
02. 将DataFrame看作二维数组
03. 其他取值方法
    如果对单个标签取值就选择列， 而对多个标签用切片就选择行，切片也可以不用索引值， 而直接用行数来实现。与之类似， 掩码操作也可以直接对每一行进行过滤， 而不需要使用loc 索引器。

### 3.4 Pandas数值运算方法

#### 3.4.1 通用函数： 保留索引

因为 Pandas 是建立在 NumPy 基础之上的， 所以 NumPy 的通用函数同样适用于 Pandas 的 Series 和 DataFrame 对象， 并且可以保留Pandas的索引和标签。

#### 3.4.2 通用函数： 索引对齐

01. Series索引对齐

    结果数组的索引是两个输入数组索引的并集。对于缺失位置的数据， Pandas 会用 NaN 填充， 表示“此处无数”。

02. DataFrame索引对齐

    在计算两个 DataFrame 时， 类似的索引对齐规则也同样会出现在共同（并集） 列中。

两个对象的行列索引可以是不同顺序的， 结果的索引会自动按顺序排列。
在 Series 中， 我们可以通过运算符方法的fill_value 参数自定义缺失值。

表3-1： Python运算符与Pandas方法的映射关系

| Python运算符 | Pandas方法 |
| ----- | ----- | 
| + | add() |
| - | sub()、 subtract() |
| * | mul()、 multiply() |
| / | truediv()、 div()、 divide() |
| // | floordiv() |
| % | mod() |
| ** |  pow() |

#### 3.4.3 通用函数： DataFrame与Series的运算

DataFrame 和 Series 的运算规则， 与NumPy 中二维数组与一维数组的运算规则是一样的。会根据 NumPy 的广播规则。

### 3.5 处理缺失值

本节以及全书涉及的缺失值主要有三种形式： null、 NaN 或 NA。

#### 3.5.1 选择处理缺失值的方法

一种方法是通过一个覆盖全局的掩码表示缺失值， 另一种方法是用一个标签值（sentinel value） 表示缺失值。

#### 3.5.2 Pandas的缺失值

Pandas 最终选择用标签方法表示缺失值，包括两种 Python 原有的缺失值： 浮点数据类型的 NaN 值， 以及 Python的 None 对象。

01. None： Python对象类型的缺失值
    Pandas 可以使用的第一种缺失值标签是 None， 它是一个 Python 单体对象，只能用于 'object' 数组类型。

02. NaN： 数值类型的缺失值
    另一种缺失值的标签是 NaN。无论和 NaN 进行何种操作， 最终结果都是NaN。

03. Pandas中NaN与None的差异

虽然 NaN 与 None 各有各的用处， 但是 Pandas 把它们看成是可以等价交换的， 在适当的时候会将两者进行替换。

表3-2： Pandas对不同类型缺失值的转换规则

| 类型 | 缺失值转换规则 | NA标签值
| ----- | ----- | ----- |
| floating 浮点型 | 无变化 | np.nan |
| object 对象类型 | 无变化 | None 或 np.nan |
| integer 整数类型 | 强制转换为 float64 | np.nan |
| boolean 布尔类型 | 强制转换为 object | None 或 np.nan |

#### 3.5.3 处理缺失值

Pandas 提供了一些方法来发现、 剔除、 替换数据结构中的缺失值:

1. `isnull()`: 创建一个布尔类型的掩码标签缺失值。
2. `notnull()`: 与 isnull() 操作相反。
3. `dropna()`: 返回一个剔除缺失值的数据。
    我们没法从 DataFrame 中单独剔除一个值， 要么是剔除缺失值所在的整行， 要么是整列。 
4. `fillna()`: 返回一个填充了缺失值的数据副本。

### 3.6 层级索引

#### 3.6.1 多级索引Series

01. 笨办法：用一个 Python 元组来表示索引

02. 好办法：Pandas多级索引

    ```python
    In[5]:  index = [('California', 2000), ('California', 2010),
                    ('New York', 2000), ('New York', 2010),
                    ('Texas', 2000), ('Texas', 2010)]
            index = pd.MultiIndex.from_tuples(index)
            index
    Out[5]: MultiIndex(levels=[['California', 'New York', 'Texas'], [2000, 2010]],
                    labels=[[0, 0, 1, 1, 2, 2], [0, 1, 0, 1, 0, 1]])

    In[6]:  pop = pop.reindex(index)
            pop
    Out[6]: California  2000 33871648
                        2010 37253956
            New York    2000 18976457
                        2010 19378102
            Texas       2000 20851820
                        2010 25145561
            dtype: int64

    In[7]: pop[:, 2010]
    Out[7]: California  37253956
            New York    19378102
            Texas       25145561
            dtype: int64
    ```

03. 高维数据的多级索引

    我们可以用一个带行列索引的简单DataFrame 代替前面的多级索引。unstack() 方法可以快速将一个多级索引的 Series 转化为
    普通索引的 DataFrame， stack() 方法则实现相反的效果：

    ```python
    In[8]:  pop_df = pop.unstack()
            pop_df
    Out[8]:             2000        2010
            California  33871648    37253956
            New York    18976457    19378102
            Texas       20851820    25145561

    In[9]:  pop_df.stack()
    Out[9]: California  2000 33871648
                        2010 37253956
            New York    2000 18976457
                        2010 19378102
            Texas       2000 20851820
                        2010 25145561
            dtype: int64
    ```

#### 3.6.2 多级索引的创建方法

为 Series 或 DataFrame 创建多级索引最直接的办法就是将 index 参数设置为至少二维的索引数组, 或者将元组作为键的字典传递给 Pandas

```python
In[12]: df = pd.DataFrame(np.random.rand(4, 2),
        index=[['a', 'a', 'b', 'b'], [1, 2, 1, 2]],columns=['data1', 'data2'])
        df
Out[12]:        data1       data2
        a   1   0.554233    0.356072
            2   0.925244    0.219474
        b   1   0.441759    0.610054
            2   0.171495    0.886688

In[13]: data = {('California', 2000): 33871648,
                ('California', 2010): 37253956,
                ('Texas', 2000): 20851820,
                ('Texas', 2010): 25145561,
                ('New York', 2000): 18976457,
                ('New York', 2010): 19378102}
        pd.Series(data)
Out[13]: California 2000    33871648
                    2010    37253956
         New York   2000    18976457
                    2010    19378102
         Texas      2000    20851820
                    2010    25145561
         dtype: int64
```

1. 显式地创建多级索引

    ```python
    In[14]: pd.MultiIndex.from_arrays([['a', 'a', 'b', 'b'], [1, 2, 1, 2]])
    Out[14]: MultiIndex(levels=[['a', 'b'], [1, 2]],
                        labels=[[0, 0, 1, 1], [0, 1, 0, 1]])

    In[15]: pd.MultiIndex.from_tuples([('a', 1), ('a', 2), ('b', 1), ('b', 2)])
    Out[15]: MultiIndex(levels=[['a', 'b'], [1, 2]],
                        labels=[[0, 0, 1, 1], [0, 1, 0, 1]])

    In[16]: pd.MultiIndex.from_product([['a', 'b'], [1, 2]])
    Out[16]: MultiIndex(levels=[['a', 'b'], [1, 2]],
                        labels=[[0, 0, 1, 1], [0, 1, 0, 1]])

    In[17]: pd.MultiIndex(levels=[['a', 'b'], [1, 2]],
                            labels=[[0, 0, 1, 1], [0, 1, 0, 1]])
    Out[17]: MultiIndex(levels=[['a', 'b'], [1, 2]],
                        labels=[[0, 0, 1, 1], [0, 1, 0, 1]])
    ```

2. 多级索引的等级名称
    给 MultiIndex 的等级加上名称会为一些操作提供便利。 你可以在前面任何一个 MultiIndex 构造器中通过 names 参数设置等级名称， 也可以在创建之后通过索引的 names 属性来修改名称。

03. 多级列索引

    每个 DataFrame 的行与列都是对称的， 也就是说既然有多级行索引， 那么同样可以有多级列索引。 

    ```python
    In[19]:
    # 多级行列索引
    index = pd.MultiIndex.from_product([[2013, 2014], [1, 2]],
                                        names=['year', 'visit'])
    columns = pd.MultiIndex.from_product([['Bob', 'Guido', 'Sue'], ['HR', 'Temp']],
                                        names=['subject', 'type'])

    # 模拟数据
    data = np.round(np.random.randn(4, 6), 1)
    data[:, ::2] *= 10
    data += 37

    # 创建DataFrame
    health_data = pd.DataFrame(data, index=index, columns=columns)
    health_data
    Out[19]: subject    Bob             Guido           Sue
             type       HR      Temp    HR      Temp    HR      Temp
             year   visit
             2013   1   31.0    38.7    32.0    36.7    35.0    37.2
                    2   44.0    37.7    50.0    35.0    29.0    36.7
             2014   1   30.0    37.4    39.0    37.8    61.0    36.9
                    2   47.0    37.8    48.0 3  7.3     51.0    36.5
    ```

