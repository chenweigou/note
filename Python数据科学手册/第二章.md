# Python 数据科学手册

[toc]

## 第二章 NumPy入门

SciPy / PyData 社区中的大多数人都用 np 作为别名导入 NumPy

```python
In[2]: import numpy as np
```

### 2.1 理解Python中的数据类型

Python 变量不仅是它们的值， 还包括了关于值的类型的一些额外信息

### 2.1.1 Python整型不仅仅是一个整型

Python 3.4 中的一个整型实际上包括 4 个部分。

* ob_refcnt 是一个引用计数， 它帮助 Python 默默地处理内存的分配和回收。
* ob_type 将变量的类型编码。
* ob_size 指定接下来的数据成员的大小。
* ob_digit 包含我们希望 Python 变量表示的实际整型值。

```C
struct _longobject {
long ob_refcnt;
PyTypeObject *ob_type;
size_t ob_size;
long ob_digit[1];
};
```

### 2.1.2 Python列表不仅仅是一个列表

列表中的每一项必须包含各自的类型信息、 引用计数和其他信息；也就是说， 每一项都是一个完整的 Python 对象。
固定类型的 NumPy 式数组缺乏这种灵活性， 但是能更有效地存储和操作数据。

### 2.1.3 Python中的固定类型数组

内置的数组（array） 模块（在 Python 3.3 之后可用） 可以用于创建统一类型的密集数组

```python
In[6]:  import array
        L = list(range(10))
        A = array.array('i', L)
        A
Out[6]: array('i', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

这里的 'i' 是一个数据类型码， 表示数据为整型。

更实用的是 NumPy 包中的 ndarray 对象。

### 2.1.4 从Python列表创建数组

NumPy 要求数组必须包含同一类型的数据。

可以用 np.array 从 Python 列表创建数组

```python
In[8]:  # 整型数组:
        np.array([1, 4, 2, 5, 3])
Out[8]: array([1, 4, 2, 5, 3])
```

如果类型不匹配， NumPy 将会向上转换(如果可行)。
如果希望明确设置数组的数据类型， 可以用 dtype 关键字：

```python
In[10]: np.array([1, 2, 3, 4], dtype='float32')
Out[10]: array([ 1., 2., 3., 4.], dtype=float32)
```

NumPy 数组可以被指定为多维的

```python
In[11]: # 嵌套列表构成的多维数组
        np.array([range(i, i + 3) for i in [2, 4, 6]])
Out[11]: array([[2, 3, 4],
                [4, 5, 6],
                [6, 7, 8]])
```

### 2.1.5 从头创建数组

```python
In[12]: # 创建一个长度为10的数组， 数组的值都是0
        np.zeros(10, dtype=int)
Out[12]: array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

In[13]: # 创建一个3×5的浮点型数组， 数组的值都是1
        np.ones((3, 5), dtype=float)
Out[13]: array([[ 1., 1., 1., 1., 1.],
                [ 1., 1., 1., 1., 1.],
                [ 1., 1., 1., 1., 1.]])

In[14]: # 创建一个3×5的浮点型数组， 数组的值都是3.14
        np.full((3, 5), 3.14)
Out[14]: array([[ 3.14, 3.14, 3.14, 3.14, 3.14],
                [ 3.14, 3.14, 3.14, 3.14, 3.14],
                [ 3.14, 3.14, 3.14, 3.14, 3.14]])

In[15]: # 创建一个3×5的浮点型数组， 数组的值是一个线性序列
        # 从0开始， 到20结束， 步长为2
        # （它和内置的range()函数类似）
        np.arange(0, 20, 2)
Out[15]: array([ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18])

In[16]: # 创建一个5个元素的数组， 这5个数均匀地分配到0~1
        np.linspace(0, 1, 5)
Out[16]: array([ 0. , 0.25, 0.5 , 0.75, 1. ])

In[17]: # 创建一个3×3的、 在0~1均匀分布的随机数组成的数组
        np.random.random((3, 3))
Out[17]: array([[ 0.99844933, 0.52183819, 0.22421193],
                [ 0.08007488, 0.45429293, 0.20941444],
                [ 0.14360941, 0.96910973, 0.946117 ]])

In[18]: # 创建一个3×3的、 均值为0、 方差为1的
        # 正态分布的随机数数组
        np.random.normal(0, 1, (3, 3))
Out[18]: array([[ 1.51772646, 0.39614948, -0.10634696],
                [ 0.25671348, 0.00732722, 0.37783601],
                [ 0.68446945, 0.15926039, -0.70744073]])

In[19]: # 创建一个3×3的、 [0, 10)区间的随机整型数组
        np.random.randint(0, 10, (3, 3))
Out[19]: array([[2, 3, 4],
                [5, 7, 8],
                [0, 5, 0]])

In[20]: # 创建一个3×3的单位矩阵
        np.eye(3)
Out[20]: array([[ 1., 0., 0.],
                [ 0., 1., 0.],
                [ 0., 0., 1.]])

In[21]: # 创建一个由3个整型数组成的未初始化的数组
        # 数组的值是内存空间中的任意值
        np.empty(3)
Out[21]: array([ 1., 1., 1.])
```

### 2.1.6 NumPy标准数据类型

构建一个数组时， 你可以用一个字符串参数来指定数据类型, 或者用相关的 NumPy 对象来指定：

```python
np.zeros(10, dtype='int16')
np.zeros(10, dtype=np.int16)
```

| 数据类型 | 描述 |
| ---- | ---- |
| bool_ | 布尔值（真、 True 或假、 False） ， 用一个字节存储 |
| int_ | 默认整型（类似于 C 语言中的 long， 通常情况下是 int64 或 int32） |
| intc | 同 C 语言的 int 相同（通常是 int32 或 int64） |
| intp | 用作索引的整型（和 C 语言的 ssize_t 相同， 通常情况下是 int32或 int64） |
| int8 | 字节（byte， 范围从–128 到 127） |
| int16 | 整型（范围从–32768 到 32767） |
| int32 | 整型（范围从–2147483648 到 2147483647） |
| int64 | 整型（范围从–9223372036854775808 到 9223372036854775807） |
| uint8 | 无符号整型（范围从 0 到 255） |
| uint16 | 无符号整型（范围从 0 到 65535） |
| uint32 | 无符号整型（范围从 0 到 4294967295） |
| uint64 | 无符号整型（范围从 0 到 18446744073709551615） |
| float_ | float64 的简化形式 |
| float16 | 半精度浮点型： 符号比特位， 5 比特位指数（exponent） ， 10 比特位尾数（mantissa） |
| float32 | 单精度浮点型： 符号比特位， 8 比特位指数， 23 比特位尾数 |
| float64 | 双精度浮点型： 符号比特位， 11 比特位指数， 52 比特位尾数 |
| complex_ | complex128 的简化形式 |
| complex64 | 复数， 由两个 32 位浮点数表示 |
| complex128 | 复数， 由两个 64 位浮点数表示 |

##　2.2 NumPy数组基础

### 2.2.1 NumPy数组的属性

每个数组有 nidm（数组的维度） 、 shape（数组每个维度的大小） 和size（数组的总大小） 属性
另外一个有用的属性是 dtype， 它是数组的数据类型
其他的属性包括表示每个数组元素字节大小的 itemsize， 以及表示数组总字节大小的属性 nbytes
**一般来说**， 可以认为 nbytes 跟 itemsize 和 size 的乘积大小相等。

### 2.2.2 数组索引： 获取单个元素

在一维数组中， 你也可以通过中括号指定索引获取第 i 个值（从 0 开始计数）
为了获取数组的末尾索引， 可以用负值索引
在多维数组中， 可以用逗号分隔的索引元组获取元素
也可以用以上索引方式修改元素值

请注意， NumPy 数组是固定类型的。

### 2.2.3 数组切片： 获取子数组

我们也可以用切片（slice） 符号获取子数组， 切片符号用冒号（:） 表示。`x[start:stop:step]`
当step为负时， start和stop默认是被交换的

你可以将索引与切片组合起来获取数组的单行和单列， 用一个冒号（:） 表示空切片, 也可以省去空切片

```python
In[28]: print(x2[:, 0]) # x2的第一列
[12 7 1]
In[29]: print(x2[0, :]) # x2的第一行
[12 5 2 4]
In[30]: print(x2[0]) #等于x2[0, :]
[12 5 2 4]
```

数组切片返回的是数组数据的视图， 而不是数值数据的副本。 在 Python 列表中， 切片是值的副本。

可以通过 copy()方法明确地复制数组里的数据或子数组

```python
In[35]: x2_sub_copy = x2[:2, :2].copy()
        print(x2_sub_copy)
[[99 5]
 [ 7 6]]
```

### 2.2.4 数组的变形

数组变形最灵活的实现方式是通过 reshape() 函数来实现。

```python
In[38]: grid = np.arange(1, 10).reshape((3, 3))
        print(grid)
[[1 2 3]
 [4 5 6]
 [7 8 9]]
```

另外一个常见的变形模式是将一个一维数组转变为二维的行或列的矩阵。 你也可以通过 reshape 方法来实现， 或者更简单地在一个切片操作中利用 newaxis 关键字：

```python
In[39]: x = np.array([1, 2, 3])
        # 通过变形获得的行向量
        x.reshape((1, 3))
Out[39]: array([[1, 2, 3]])

In[40]: # 通过newaxis获得的行向量
        x[np.newaxis, :]
Out[40]: array([[1, 2, 3]])

In[41]: # 通过变形获得的列向量
        x.reshape((3, 1))
Out[41]: array([[1],
                [2],
                [3]])

In[42]: # 通过newaxis获得的列向量
        x[:, np.newaxis]
Out[42]: array([[1],
                [2],
                [3]])
```

### 2.2.5 数组拼接和分裂

1. 数组的拼接
    拼接或连接 NumPy 中的两个数组主要由np.concatenate、 np.vstack 和 np.hstack 例程实现。 np.concatenate 将数组元组或数组列表作为第一个参数

    ```python
    In[43]: x = np.array([1, 2, 3])
            y = np.array([3, 2, 1])
            np.concatenate([x, y])
    Out[43]: array([1, 2, 3, 3, 2, 1])
    ```

    你也可以一次性拼接两个以上数组, np.concatenate 也可以用于二维数组的拼接

    ```python
    In[44]: z = [99, 99, 99]
            print(np.concatenate([x, y, z]))
    [ 1 2 3 3 2 1 99 99 99]

    In[45]: grid = np.array([[1, 2, 3],
                             [4, 5, 6]])

    In[46]: # 沿着第一个轴拼接
            np.concatenate([grid, grid])

    Out[46]: array([[1, 2, 3],
                   [4, 5, 6],
                   [1, 2, 3],
                   [4, 5, 6]])

    In[47]: # 沿着第二个轴拼接（从0开始索引）
            np.concatenate([grid, grid], axis=1)
    Out[47]: array([[1, 2, 3, 1, 2, 3],
                    [4, 5, 6, 4, 5, 6]])
    ```

    沿着固定维度处理数组时， 使用 np.vstack（垂直栈） 和np.hstack（水平栈） 函数会更简洁

    ```python
    In[48]: x = np.array([1, 2, 3])
            grid = np.array([[9, 8, 7],
                             [6, 5, 4]])
            # 垂直栈数组
            np.vstack([x, grid])
    Out[48]: array([[1, 2, 3],
                    [9, 8, 7],
                    [6, 5, 4]])

    In[49]: # 水平栈数组
            y = np.array([[99],
                          [99]])
            np.hstack([grid, y])
    Out[49]: array([[ 9, 8, 7, 99],
                    [ 6, 5, 4, 99]])
    ```

    与之类似， np.dstack 将沿着第三个维度拼接数组。

2. 数组的分裂

    与拼接相反的过程是分裂。 分裂可以通过 np.split、 np.hsplit和 np.vsplit 函数来实现。

    ```python
    In[50]: x = [1, 2, 3, 99, 99, 3, 2, 1]
            x1, x2, x3 = np.split(x, [3, 5])
            print(x1, x2, x3)
    [1 2 3] [99 99] [3 2 1]
    ```

    相关的np.hsplit 和 np.vsplit 的用法也类似：

    ```python
    In[51]: grid = np.arange(16).reshape((4, 4))
            grid
    Out[51]: array([[ 0, 1, 2, 3],
                    [ 4, 5, 6, 7],
                    [ 8, 9, 10, 11],
                    [12, 13, 14, 15]])

    In[52]: upper, lower = np.vsplit(grid, [2])
            print(upper)
            print(lower)
    [[0 1 2 3]
     [4 5 6 7]]
    [[ 8 9 10 11]
     [12 13 14 15]]

    In[53]: left, right = np.hsplit(grid, [2])
            print(left)
            print(right)
    [[ 0 1]
     [ 4 5]
     [ 8 9]
     [12 13]]
    [[ 2 3]
     [ 6 7]
     [10 11]
     [14 15]]
    ```

同样， np.dsplit 将数组沿着第三个维度分裂
