# 马拉车(Manacher)算法

## 题目

这里以leetcode题目([647. 回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)) 为例介绍Manacher算法

    给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。
    具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

    示例 1：
        输入："abc"
        输出：3
        解释：三个回文子串: "a", "b", "c"

    示例 2：
        输入："aaa"
        输出：6
        解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

## 解法一

这道题最容易想到的方法是枚举每个位置为中心, 向左右扩展, 计算并统计得到的回文子串
该方法是时间复杂度是(O<sup>2</sup>)

## Manacher 算法

Manacher 算法是在线性时间内求解最长回文子串的算法。该方法也是通过枚举并计算每个位置为中心的最长回文子串来得到最长回文子串。最长回文子串的半径也是相同中心的回文子串的数目, 在这里, 我们可以通过统计以每个位置为中心的回文子串的数目来得到题目的答案

Manacher 算法和解法一不同的是该方法通过记录状态可以在平均 O(1) 的时间复杂内计算出以某个位置为中心的回文子串数目, 使总的时间复杂度达到 O(n)

首先, 因为长度为偶数的回文子串没有中心, 比较不好处理, 所以我们在原字符串的每个字符串添加一个肯定不会出现的字符, 在首尾再添加两个其他的字符, 比如`aba`处理成`$#a#b#a#^`, 首尾字符的作用是防止越界

然后我们定义 `F[i]` 表示第i个位置的回文子串的最长半径, 定义`R`, `L`来表示当前找到的回文子串的最右边界, 以及对应的最左边界, 即每当 `i+F[i]-1>R` 时, `L=i-F[i]+1 R=i+F[i]-1`

然后是 `F[i]` 的计算:

* 当`i < R`时, 因为`L`, `R` 范围内的子串是对称的, 所以当以 `i` 为中心有一个回文子串时, 肯定有以 `j=L+(R-i)` 为中心的相同的回文子串, 反之亦然, 但是如果以 `j` 的回文子串的范围超过了 `L`, 以 `i` 为中心的子串超过 `R` 的部分就不是对称的了 (因为如果以 `i` 为中心的子串超过 `R` 的部分是对称的, 那 `L`, `R` 的范围可以更大)。所以 `F[i]=min(F[L+R-i], R-i+1)`
*这里 `R-i+1` 的部分我看了好久一直没看懂怎么保证 `[i, R]`的部分和`[i-(R-i), i]`是对称的, 后来才明白它要和 `F[L+R-i]` 结合起来看, 如果 `F[i]=R-i+1`, 那就表示 `F[L+R-i]>R-i+1`, 就可以保证`[i, R]` 和 `[i-(R-i), i]`的对称*
* 当`i > R`时, 以 `i` 为中心肯定有一个长度为1的回文子串, 所以 `F[i]=1`

再通过循环比较 `i-F[i]` 和 `i+F[i]` 的值计算出`F[i]`的最终值(这里因为在子符串的首尾添加了两个肯定不相等的字符, 可以不用担心越界)

最后 `F[i] // 2` 的和即题目的答案 (`F[i]` 和以 `i`为中心的原始回文子串的数目的关系可以自己推)

最后附上代码:

```python
class Solution:
    def countSubstrings(self, s: str) -> int:

        tmp = ['$#']
        for c in s:
            tmp.append(c+'#')
        tmp.append('^')
        s = ''.join(tmp)
        del tmp

        dp = [0] * len(s)

        l, r, ans = 0, 0, 0

        for i in range(1, len(s)-1):
            dp[i] = min(dp[l+r-i], r-i+1) if i < r else 1
            while s[i-dp[i]] == s[i+dp[i]]:
                dp[i]+=1
            if i+dp[i]-1 > r:
                l, r = i-dp[i]+1, i+dp[i]-1
            ans += dp[i] // 2

        return ans
```
