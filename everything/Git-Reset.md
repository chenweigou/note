# git reset 和 git checkout

## Git 的思维框架

Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的:

| 树 | 用途 |
| ---- | ---- |
| HEAD | 上一次提交的快照，下一次提交的父结点 |
| Index | 预期的下一次提交的快照 |
| Working Directory | 沙盒 |

### HEAD

HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做*你的上一次提交*的快照。

### 索引

索引是你的*预期的下一次提交*。我们也会将这个概念引用为 Git 的 “暂存区域”，这就是当你运行 `git commit` 时 Git 看起来的样子。当你运行 `git add` 时就会更新索引的内容

### 工作目录

工作目录你看到的项目里面实际的文件

## git reset

`git reset` 有两种使用方法, 一种是以提交节点为参数, 一种是以提交节点及文件路径为参数

### 以提交节点为参数

当以提交节点为参数时, Git 会将当前分支的指针指向指定的节点, 即使用指定节点的提交历史覆盖当前分支的提交历史,
然后将HEAD指针指向指定节点。

使用 `--soft` 选项, Git 仅仅更新你的HEAD, 你的索引不会被更新。你reset前暂存的修改以及reset前后的文件变化都会处于暂存状态
使用 `--mixed` 选项, Git 会更新你的HEAD和索引。 这个选项会清空你的暂存区。这是默认选项
使用 `--hard` 选项, Git 更新你的HEAD, 索引和工作目录, 你对已经已经纳入版本控制的文件的所有修改都会被清空。请谨慎使用

PS: 纳入版本控制指的是你有过提交记录的文件或者已经添加到暂存区的文件, 仅仅新建在放在项目文件夹内的文件不会自动纳入版本控制。`git commit -a` 可以在提交前将修改自动暂存, 指的是被纳入版本控制的文件的修改

### 以提交节点和文件路径为参数

当以提交节点和文件路径为参数时, Git 会用指定节点的指定文件更新你的 index 区域。工作目录中指定的文件不会被修改，和指定节点之间的差异会处于暂存状态。当使用这种参数模式时，不能指定 `--soft`, `--hard`, 或 `--mixed` 选项。

## git checkout

`git checkout` 可以将Head切换到指定的提交节点或分支上

当切换到指定的提交节点时, Git 会创建一个临时的分支。你可以在临时分支上正常的修改提交, 你也可以通过命令 `git switch -c <新分支名>` 来在当前位置创建新的分支, 如果你没有创建新的分支, 当你切换到其他分支时, 你在临时分支上的提交将会被丢弃。

PS: 从临时分支切换到其他分支后, 你在提交历史上看不到你在临时分支上的提交。 不过你仍可以通过 `git reflog` 查看你的节点切换历史, 找到你的提交历史的hash码。

运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file那样用该次提交中的那个文件来更新Index，但是它也会覆盖工作目录中对应的文件。 它就像是git reset --hard [branch] file(如果reset允许你这样运行的话)-这样对工作目录并不 安全，它也不会移动 HEAD。

## 区别

* git reset 之后HEAD仍然指向原来的分支, 但是会用指定节点的提交历史记录来覆盖所在分支的历史
* git checkout 会切换到新的分支, 不会影响分支的记录

