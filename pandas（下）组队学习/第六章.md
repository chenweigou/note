# Pandas（下）组队学习

[返回](./index.md)
[toc]

## 第6章 缺失数据

```python
In[1]:  import pandas as pd
        import numpy as np
        df = pd.read_csv('data/table_missing.csv')
        df.head()
Out[1]:   School Class      ID Gender   Address  Height  Weight  Math Physics
        0    S_1   C_1     NaN      M  street_1     173     NaN  34.0      A+
        1    S_1   C_1     NaN      F  street_2     192     NaN  32.5      B+
        2    S_1   C_1  1103.0      M  street_2     186     NaN  87.2      B+
        3    S_1   NaN     NaN      F  street_2     167    81.0  80.4     NaN
        4    S_1   C_1  1105.0    NaN  street_4     159    64.0  84.8      A-
```

### 一、缺失观测及其类型

#### 1. 了解缺失信息

1. 使用isna方法和notna方法检查pandas数据是否有缺失值

    对Series使用会返回布尔列表

    ```python
    In[2]: df['Physics'].isna().head()
    Out[2]: 0    False
            1    False
            2    False
            3     True
            4    False
            Name: Physics, dtype: bool
    ```

    对DataFrame使用会返回布尔表

    ```python
    In[3]: df.isna().head()
    Out[3]:    School  Class     ID  Gender  Address  Height  Weight   Math  Physics
            0   False  False   True   False    False   False    True  False    False
            1   False  False   True   False    False   False    True  False    False
            2   False  False  False   False    False   False    True  False    False
            3   False   True   True   False    False   False   False  False     True
            4   False  False  False    True    False   False   False  False    False
    ```

    但对于DataFrame我们更关心到底每列有多少缺失值

    ```python
    In[4]: df.isna().sum()
    In[4]:  School      0
            Class       4
            ID          6
            Gender      7
            Address     0
            Height      0
            Weight     13
            Math        5
            Physics     4
            dtype: int64
    ```

    要统计每列有多少非缺失值可以用`df.notna().sum()` 或 **`df.count()`**。

2. 可以用返回的布尔数组当索引来查看缺失值所在行

    ```python
    In[5]: df[df['Physics'].isna()]
    Out[5]:    School Class      ID Gender   Address  Height  Weight  Math Physics
            3     S_1   NaN     NaN      F  street_2     167    81.0  80.4     NaN
            8     S_1   C_2  1204.0      F  street_5     162    63.0  33.8     NaN
            13    S_1   C_3  1304.0    NaN  street_2     195    70.0  85.2     NaN
            22    S_2   C_2  2203.0      M  street_4     155    91.0  73.8     NaN
    ```

3. 挑选出所有非缺失值列
    使用all就是全部非缺失值，如果是any就是至少有一个不是缺失值

    ```python
    In[5]: df[df.notna().all(1)]
    Out[5]:   School Class      ID Gender   Address  Height  Weight  Math Physics
        5     S_1   C_2  1201.0      M  street_5     159    68.0  97.0      A-
        6     S_1   C_2  1202.0      F  street_4     176    94.0  63.5      B-
        12    S_1   C_3  1303.0      M  street_7     188    82.0  49.7       B
        17    S_2   C_1  2103.0      M  street_4     157    61.0  52.5      B-
        21    S_2   C_2  2202.0      F  street_7     194    77.0  68.5      B+
        25    S_2   C_3  2301.0      F  street_4     157    78.0  72.3      B+
        27    S_2   C_3  2303.0      F  street_7     190    99.0  65.9       C
        28    S_2   C_3  2304.0      F  street_6     164    81.0  95.5      A-
        29    S_2   C_3  2305.0      M  street_4     187    73.0  48.9       B
    ```

#### 2. 三种缺失符号

|　np.nan | None | NaT| 
|----| ---- | ---- |
| np.nan是一个麻烦的东西，首先它不等与任何东西，甚至不等于自己 | None会等于自身 |  NaT是针对时间序列的缺失值，是Pandas的内置类型，可以完全看做时序版本的np.nan | 
| 在用equals函数比较时，自动略过两侧全是np.nan的单元格，因此结果不会影响 | None的布尔值为False | Nat与自己不等 |
| 其次，它在numpy中的类型为浮点，由此导致数据集读入时，即使原来是整数的列，只要有缺失值就会变为浮点型 | 修改布尔列表不会改变数据类型 | Nat使用equals时也会被跳过 |
| 此外，对于布尔类型的列表，如果是np.nan填充，那么它的值会自动变为True而不是False | 在传入数值类型后，会自动变为np.nan | 
| 但当修改一个布尔列表时，会改变列表类型，而不是赋值为True | 只有当传入object类型是保持不动，几乎可以认为，除非人工命名None，它基本不会自动出现在Pandas中 |
| 在所有的表格读取后，无论列是存放什么类型的数据，默认的缺失值全为np.nan类型 | 在使用equals函数时不会被略过，因此下面的情况下返回False | 

#### 3. Nullable类型与NA符号

这是Pandas在1.0新版本中引入的重大改变，其目的就是为了（在若干版本后）解决之前出现的混乱局面，统一缺失值处理方法

Nullable是一系列可以表示缺失值的数据类型

Nullable类似的缺失值在数据里面被设置为pd.NA

1. Nullable整形: 'Int'

    对于该种类型而言，它与原来标记int上的符号区别在于首字母大写：
    它的好处就在于，其中前面提到的三种缺失值都会被替换为统一的NA符号，且不改变数据类型

2. Nullable布尔: boolean

    需要注意的是，在1.0.2之前的版本含有pd.NA的布尔列表作为索引时会报错， 已修复

3. string类型: string

    string和object类型的一点重要区别就在于，在调用字符方法后，string类型返回的是Nullable类型，object则会根据缺失类型和数据类型而改变

#### 4. NA的特性

1. pd.NA做逻辑运算时只需看该逻辑运算的结果是否依赖pd.NA的取值，如果依赖，则结果还是NA，如果不依赖，则直接计算结果

    ```python
    In [6]: type(pd.NA)
    Out[6]: pandas._libs.missing.NAType

    In [7]: True | pd.NA
    Out[7]: True

    In [8]: pd.NA | True
    Out[8]: True

    In [9]: False | pd.NA
    Out[9]: <NA>

    In [10]: False & pd.NA
    Out[10]: False

    In [11]: True & pd.NA
    Out[11]: <NA>
    ```

    pd.NA 不能使用 and 和 or
    np.nan, None, Nat 不能用 | 和 &， 只能用 and 和 or

2. 算术运算和比较运算

    除了下面两种情况， 其他都是pd.NA

    ```python
    In [12]: pd.NA ** 0
    Out[12]: 1

    In [13]: 1 ** pd.NA
    Out[13]: 1
    ```

#### 5. convert_dtypes方法

这个函数的功能在读取数据时，就把数据列转为Nullable类型，是1.0的新函数

```python
In [13]: pd.read_csv('data/table_missing.csv').dtypes
Out[13]:
School      object
Class       object
ID         float64
Gender      object
Address     object
Height       int64
Weight     float64
Math       float64
Physics     object
dtype: object

In [14]: pd.read_csv('data/table_missing.csv').convert_dtypes().dtypes
Out[14]:
School      string
Class       string
ID           Int64
Gender      string
Address     string
Height       Int64
Weight       Int64
Math       float64
Physics     string
dtype: object
```

### 五、问题与练习

#### 1. 问题

【问题一】 如何删除缺失值占比超过25%的列？  

`df.loc[:, df.isna().sum()/df.shape[0] <= 0.25]`

【问题二】 什么是Nullable类型？请谈谈为什么要引入这个设计？

Nullable是一系列可以表示缺失值的数据类型, 引入这个设计的目的就是为了（在若干版本后）解决之前出现的混乱局面，统一缺失值处理方法。

【问题三】 对于一份有缺失值的数据，可以采取哪些策略或方法深化对它的了解？